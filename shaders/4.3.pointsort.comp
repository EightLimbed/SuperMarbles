#version 430 core
// run three work groups, one for each insertion sort
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) buffer ChunkData {
    uint numPoints;
    vec4 points[];
};

layout(std430, binding = 1) buffer ChunkDataSort {
    uint isort[];
};

// binary search function. idk how tf this works, I got it from some random c++ tutorial and rewrote it in GLSL
int binarySearch(uint offset, uint count, float value, uint axis) {
    int low = 0;
    int high = int(count) - 1;
    while (low < high) {
        int mid = (low + high) / 2;
        uint idx = isort[offset + uint(mid)];
        float coord = (axis == 0u) ? points[idx].x : (axis == 1u) ? points[idx].y : points[idx].z;
        if (coord < value) low = mid + 1;
        else high = mid;
    }
    return low;
}

// binary-insertion sort for one axisâ€™ slice: [offset .. offset+n)
void insertionSort(uint offset, uint n, int component) {
    // insertion sort with binary search for the insert location.
    for (uint i = 1u; i < n; ++i) {
        uint selected = isort[offset + i];

        int loc = binarySearch(offset, i, selected, component);

        // shift right to make room
        int j = int(offset + i) - 1;
        while (j >= loc) {
            isort[j + 1] = isort[j];
            --j;
        }
        isort[loc] = selected;
    }
}

void main() {
    // one workgroup per axis.
    uint axis = gl_WorkGroupID.x;
    if (axis >= 3u) return;

    // only one invocation per workgroup performs the sequential sort.
    if (gl_LocalInvocationIndex != 0u) return;

    uint offset = axis * numPoints;
    int component = int(axis);

    insertionSort(offset, numPoints, component);

    // make results visible to subsequent passes
    memoryBarrierBuffer();
    barrier(); // local barrier
}